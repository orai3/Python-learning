"""
Super-Exploitation Metrics

Analysis tools for measuring super-exploitation of labor in peripheral economies.

Theoretical Foundation:
Super-exploitation occurs when labor is paid below the value of labor-power,
either through:
1. Wages below subsistence (absolute super-exploitation)
2. Wages below productivity-adjusted norms (relative super-exploitation)
3. Intensification of labor without compensation
4. Extension of working day without proportional wage increase

Key Theorists:
- Ruy Mauro Marini: Dialectics of Dependency
- Samir Amin: Accumulation on a World Scale
- Andy Higginbottom: Structure and essence in Capital 1
- John Smith: Imperialism in the Twenty-First Century

Metrics:
1. Wage-productivity gap
2. Labor share of income
3. Real wage vs subsistence basket
4. Working hours and intensity
5. Informal/precarious work share
6. Gender wage gaps
7. Comparison to value of labor-power
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass


@dataclass
class LaborData:
    """Labor market and exploitation data"""
    workers: int  # Number of workers
    hours_worked: float  # Total hours
    total_wages: float  # Total wage bill
    output_value: float  # Value of output
    subsistence_cost: float  # Cost of subsistence basket
    social_reproduction_cost: float  # Full cost of labor-power reproduction


class SuperExploitationMetrics:
    """
    Calculate various metrics of super-exploitation.
    """

    def __init__(self):
        """Initialize super-exploitation analyzer"""
        self.labor_data: Dict[str, LaborData] = {}
        self.reference_country: Optional[str] = None

    def add_country(self, country: str, data: LaborData):
        """
        Add country labor data.

        Args:
            country: Country identifier
            data: Labor market data
        """
        self.labor_data[country] = data

    def set_reference_country(self, country: str):
        """
        Set reference country (typically a core country) for comparisons.

        Args:
            country: Reference country
        """
        if country not in self.labor_data:
            raise ValueError(f"Country {country} not in dataset")
        self.reference_country = country

    def calculate_wage_productivity_gap(self, country: str) -> Dict[str, float]:
        """
        Calculate gap between wages and productivity.

        If productivity grows faster than wages, workers are increasingly
        exploited (produce more value per hour but receive proportionally less).

        Args:
            country: Country to analyze

        Returns:
            Wage-productivity metrics
        """
        data = self.labor_data[country]

        # Productivity (output per hour)
        productivity = data.output_value / data.hours_worked if data.hours_worked > 0 else 0

        # Wage per hour
        wage_per_hour = data.total_wages / data.hours_worked if data.hours_worked > 0 else 0

        # Productivity-wage ratio
        prod_wage_ratio = productivity / wage_per_hour if wage_per_hour > 0 else 0

        # Compare to reference if available
        if self.reference_country:
            ref_data = self.labor_data[self.reference_country]
            ref_productivity = ref_data.output_value / ref_data.hours_worked if ref_data.hours_worked > 0 else 0
            ref_wage = ref_data.total_wages / ref_data.hours_worked if ref_data.hours_worked > 0 else 0
            ref_ratio = ref_productivity / ref_wage if ref_wage > 0 else 0

            relative_exploitation = prod_wage_ratio / ref_ratio if ref_ratio > 0 else 0
        else:
            relative_exploitation = 0

        return {
            'productivity_per_hour': productivity,
            'wage_per_hour': wage_per_hour,
            'productivity_wage_ratio': prod_wage_ratio,
            'rate_of_exploitation': (prod_wage_ratio - 1) * 100,  # Percentage
            'relative_to_reference': relative_exploitation,
            'super_exploitation_index': max(0, relative_exploitation - 1) * 100
        }

    def calculate_wage_subsistence_gap(self, country: str) -> Dict[str, float]:
        """
        Calculate gap between actual wages and subsistence requirements.

        Absolute super-exploitation occurs when wages fall below subsistence.

        Args:
            country: Country to analyze

        Returns:
            Wage-subsistence metrics
        """
        data = self.labor_data[country]

        # Average wage per worker
        avg_wage = data.total_wages / data.workers if data.workers > 0 else 0

        # Subsistence per worker (annual)
        subsistence_per_worker = data.subsistence_cost / data.workers if data.workers > 0 else 0

        # Social reproduction cost per worker
        reproduction_cost = data.social_reproduction_cost / data.workers if data.workers > 0 else 0

        # Gaps
        subsistence_gap = avg_wage - subsistence_per_worker
        reproduction_gap = avg_wage - reproduction_cost

        return {
            'average_wage': avg_wage,
            'subsistence_cost': subsistence_per_worker,
            'reproduction_cost': reproduction_cost,
            'subsistence_gap': subsistence_gap,
            'subsistence_gap_pct': (subsistence_gap / subsistence_per_worker * 100) if subsistence_per_worker > 0 else 0,
            'reproduction_gap': reproduction_gap,
            'reproduction_gap_pct': (reproduction_gap / reproduction_cost * 100) if reproduction_cost > 0 else 0,
            'absolute_super_exploitation': subsistence_gap < 0,
            'relative_super_exploitation': reproduction_gap < 0
        }

    def calculate_labor_share(self, country: str) -> Dict[str, float]:
        """
        Calculate labor share of income.

        Declining labor share indicates increasing exploitation.

        Args:
            country: Country to analyze

        Returns:
            Labor share metrics
        """
        data = self.labor_data[country]

        # Labor share
        labor_share = (data.total_wages / data.output_value * 100) if data.output_value > 0 else 0

        # Capital share (residual)
        capital_share = 100 - labor_share

        # Rate of exploitation (Marxian)
        # s/v = surplus value / variable capital
        # = (output - wages) / wages
        rate_of_exploitation = ((data.output_value - data.total_wages) / data.total_wages * 100) \
                              if data.total_wages > 0 else 0

        # Compare to reference
        if self.reference_country:
            ref_data = self.labor_data[self.reference_country]
            ref_labor_share = (ref_data.total_wages / ref_data.output_value * 100) if ref_data.output_value > 0 else 0
            labor_share_gap = labor_share - ref_labor_share
        else:
            labor_share_gap = 0

        return {
            'labor_share': labor_share,
            'capital_share': capital_share,
            'rate_of_exploitation': rate_of_exploitation,
            'labor_share_gap_vs_reference': labor_share_gap,
            'excess_exploitation': -labor_share_gap if labor_share_gap < 0 else 0
        }

    def calculate_international_value_transfer(self, country: str) -> Dict[str, float]:
        """
        Estimate value transferred through super-exploitation.

        If workers in periphery were paid at core country rates (adjusted for
        productivity), how much value would be retained locally vs transferred?

        Args:
            country: Country to analyze

        Returns:
            Value transfer estimates
        """
        if not self.reference_country:
            return {}

        data = self.labor_data[country]
        ref_data = self.labor_data[self.reference_country]

        # Productivity ratio
        productivity = data.output_value / data.hours_worked if data.hours_worked > 0 else 0
        ref_productivity = ref_data.output_value / ref_data.hours_worked if ref_data.hours_worked > 0 else 0
        productivity_ratio = productivity / ref_productivity if ref_productivity > 0 else 0

        # Reference wage adjusted for productivity
        ref_wage_per_hour = ref_data.total_wages / ref_data.hours_worked if ref_data.hours_worked > 0 else 0
        adjusted_wage = ref_wage_per_hour * productivity_ratio

        # Actual wage
        actual_wage_per_hour = data.total_wages / data.hours_worked if data.hours_worked > 0 else 0

        # Wage gap
        wage_gap_per_hour = adjusted_wage - actual_wage_per_hour

        # Total value transferred
        value_transferred = wage_gap_per_hour * data.hours_worked

        return {
            'actual_total_wages': data.total_wages,
            'productivity_adjusted_wages': adjusted_wage * data.hours_worked,
            'wage_gap_per_hour': wage_gap_per_hour,
            'total_value_transferred': value_transferred,
            'transfer_as_pct_output': (value_transferred / data.output_value * 100) if data.output_value > 0 else 0,
            'transfer_as_pct_wages': (value_transferred / data.total_wages * 100) if data.total_wages > 0 else 0
        }

    def analyze_historical_trend(self, country: str,
                                time_series: pd.DataFrame) -> Dict[str, any]:
        """
        Analyze historical trends in exploitation.

        Args:
            country: Country to analyze
            time_series: DataFrame with columns: year, wages, productivity, labor_share

        Returns:
            Trend analysis
        """
        # Calculate wage-productivity decoupling
        time_series['wage_index'] = time_series['wages'] / time_series['wages'].iloc[0] * 100
        time_series['productivity_index'] = time_series['productivity'] / time_series['productivity'].iloc[0] * 100
        time_series['decoupling'] = time_series['productivity_index'] - time_series['wage_index']

        # Trends
        from scipy import stats

        years = np.arange(len(time_series))

        # Labor share trend
        ls_slope, ls_intercept, ls_r, ls_p, ls_se = stats.linregress(
            years, time_series['labor_share']
        )

        # Decoupling trend
        dc_slope, dc_intercept, dc_r, dc_p, dc_se = stats.linregress(
            years, time_series['decoupling']
        )

        return {
            'labor_share_trend': ls_slope,  # Percentage points per year
            'labor_share_total_change': ls_slope * len(years),
            'labor_share_significant': ls_p < 0.05,
            'decoupling_trend': dc_slope,
            'total_decoupling': time_series['decoupling'].iloc[-1],
            'decoupling_significant': dc_p < 0.05,
            'intensifying_exploitation': ls_slope < 0 and dc_slope > 0,
            'time_series': time_series
        }

    def calculate_gender_exploitation_gap(self, country: str,
                                         male_wages: float,
                                         female_wages: float,
                                         male_hours: float,
                                         female_hours: float) -> Dict[str, float]:
        """
        Analyze gendered dimensions of super-exploitation.

        Women in periphery often face double exploitation:
        1. Lower wages than men for same work
        2. Lower wages than core country workers

        Args:
            country: Country to analyze
            male_wages: Total male wages
            female_wages: Total female wages
            male_hours: Total male hours
            female_hours: Total female hours

        Returns:
            Gender gap metrics
        """
        male_wage_per_hour = male_wages / male_hours if male_hours > 0 else 0
        female_wage_per_hour = female_wages / female_hours if female_hours > 0 else 0

        gender_wage_gap = (male_wage_per_hour - female_wage_per_hour) / male_wage_per_hour * 100 \
                         if male_wage_per_hour > 0 else 0

        return {
            'male_wage_per_hour': male_wage_per_hour,
            'female_wage_per_hour': female_wage_per_hour,
            'gender_wage_gap_pct': gender_wage_gap,
            'female_to_male_ratio': female_wage_per_hour / male_wage_per_hour if male_wage_per_hour > 0 else 0,
            'total_gender_penalty': (male_wage_per_hour - female_wage_per_hour) * female_hours
        }

    def calculate_informal_sector_exploitation(self,
                                               formal_wage: float,
                                               informal_wage: float,
                                               informal_share: float) -> Dict[str, float]:
        """
        Analyze super-exploitation in informal sector.

        Informal workers typically lack:
        - Legal protections
        - Social security
        - Collective bargaining
        - Job security

        Leading to severe exploitation.

        Args:
            formal_wage: Average formal sector wage
            informal_wage: Average informal sector wage
            informal_share: Share of workforce in informal sector

        Returns:
            Informal sector metrics
        """
        wage_penalty = (formal_wage - informal_wage) / formal_wage * 100 if formal_wage > 0 else 0

        # Aggregate impact
        weighted_avg_wage = formal_wage * (1 - informal_share) + informal_wage * informal_share
        wage_suppression = (formal_wage - weighted_avg_wage) / formal_wage * 100 if formal_wage > 0 else 0

        return {
            'formal_wage': formal_wage,
            'informal_wage': informal_wage,
            'informal_wage_penalty_pct': wage_penalty,
            'informal_share_pct': informal_share * 100,
            'weighted_average_wage': weighted_avg_wage,
            'wage_suppression_effect': wage_suppression
        }

    def get_super_exploitation_index(self, country: str) -> float:
        """
        Calculate composite super-exploitation index (0-100 scale).

        Combines multiple indicators:
        - Wage-productivity gap
        - Wage-subsistence gap
        - Labor share
        - Comparison to reference country

        Higher values indicate more severe super-exploitation.

        Args:
            country: Country to analyze

        Returns:
            Super-exploitation index
        """
        wp_gap = self.calculate_wage_productivity_gap(country)
        ws_gap = self.calculate_wage_subsistence_gap(country)
        labor_share = self.calculate_labor_share(country)

        # Normalize components to 0-100 scale
        # (This is simplified - would need proper normalization in practice)

        component1 = min(100, wp_gap.get('super_exploitation_index', 0))
        component2 = 50 if ws_gap.get('relative_super_exploitation', False) else 0
        component3 = max(0, labor_share.get('excess_exploitation', 0))

        # Weighted average
        index = (component1 * 0.4 + component2 * 0.3 + component3 * 0.3)

        return min(100, index)
